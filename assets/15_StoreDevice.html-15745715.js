import{_ as e,o as a,c as s,e as n}from"./app-21fd3c9b.js";const p={},t=n(`<h1 id="_15-存储设备" tabindex="-1"><a class="header-anchor" href="#_15-存储设备" aria-hidden="true">#</a> 15 存储设备</h1><h2 id="_15-1-sd-tf卡-u盘使用步骤" tabindex="-1"><a class="header-anchor" href="#_15-1-sd-tf卡-u盘使用步骤" aria-hidden="true">#</a> 15.1 SD/TF卡，U盘使用步骤</h2><h3 id="_15-1-1-sd-tf卡-u盘的硬件接口" tabindex="-1"><a class="header-anchor" href="#_15-1-1-sd-tf卡-u盘的硬件接口" aria-hidden="true">#</a> 15.1.1 SD/TF卡，U盘的硬件接口</h3><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0001.png" alt=""></p><p>​ 如上图的100ask6ull开发板，⑦为USB口，U盘从这里插入；⑱为mico sd卡槽，micro sd卡可以直接从这里插入。</p><p>​ 注：micro sd卡也叫tf卡，它是sd卡类的一种，还有sd卡，mini sd卡等，我们简称这一类都叫sd卡。</p><h3 id="_15-1-2-确定设备点" tabindex="-1"><a class="header-anchor" href="#_15-1-2-确定设备点" aria-hidden="true">#</a> 15.1.2 确定设备点</h3><p>①U盘确定设备点</p><p>​ 下图是未插入U盘前/dev/目录下的内容</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0002.png" alt=""></p><p>​ 当我们插入U盘后/dev/目录下的内容为下图</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0003.png" alt=""></p><p>​ 由这两幅图，可以清楚看到插入U盘后，/dev/目录下多了sda，sda1，很显然这两个东西就是和我们的U盘有关的。</p><p>​ 当我们插入U盘linux系统一般都会提示该设备节点是哪个，下图就是当我们插入U盘后我们串口终端接收的信息，上面提示了有U盘插入，同时设备节点是sda</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0004.png" alt=""></p><p>​ sd表示这是个scsi，sata硬盘设备。</p><p>​ a：表示这是第一块硬盘，</p><p>​ 1：这是这块硬盘的第一个分区，同时也是主分区。</p><p>​ 根据以上内容，我们应该就能看出sda，sda1表示什么意思了。</p><p>​ sda表示整个U盘存储设备</p><p>​ sda1表示是sda的第一个分区。</p><p>②SD卡确定设备点</p><p>​ 下图是未插入SD卡前/dev/目录下的内容</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0002.png" alt=""></p><p>​ 当我们插入SD卡后/dev/目录下的内容为下图</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0005.png" alt=""></p><p>​ 由这两幅图，可以清楚看到插入SD卡后，/dev/目录下多了mmcblk0，mmcblk0p1，很显然这两个东西就是和我们的SD卡有关的。</p><p>​ 当我们插入sd卡，linux系统一般都会提示该设备节点是哪个，下图就是当我们插入sd卡后我们串口终端接收的信息，上面提示了有sd卡插入，同时设备节点是mmcblk0</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0006.png" alt=""></p><p>​ mmc 应该是 sd 的前身，所以sd与mmc 的驱动通用，于是Linux 就把设备节点名称延续下来了。</p><p>blk表示这是块设备，随后跟的数字是该设备的编号blk0，表示编号为0的块设备，区分块设备用的。</p><p>​ p表示是分区，p1 表示这是第一个分区。</p><p>​ 根据以上内容，我们应该就能看出mmcblk0，mmcblk0p1表示什么意思了。</p><p>​ mmcblk0表示整个sd卡设备</p><p>​ mmcblk0p1表示这是sd卡设备的第一个分区。</p><h3 id="_15-1-3-分区" tabindex="-1"><a class="header-anchor" href="#_15-1-3-分区" aria-hidden="true">#</a> 15.1.3 分区</h3><p>​ 我们使用fdisk工具来分区，</p><p>​ 执行fdisk /dev/mmcblk0后，输入m（进入菜单功能选项）进入 fdisk 画面：</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0007.png" alt=""></p><p>​ 常用的是：d l m p q t w命令</p><p>​ 我们尝试利用剩余空间增加一个分区</p><p>​ 此时按下w 就可以将分区信息存储到分区表中，并离开 fdisk；如果你决定这样的操作不对，也可以直接按下 q 取消刚刚的fdisk工具的所有动作，并退出fdisk。</p><h3 id="_15-1-4-格式化并挂载" tabindex="-1"><a class="header-anchor" href="#_15-1-4-格式化并挂载" aria-hidden="true">#</a> 15.1.4 格式化并挂载</h3><p>​ 上一小节，我们新建立了一个分区，我们的第二个分区为 /dev/mmcblk0p2 ，分区类型为 Linux ,此时我们可以mkfs.ext3 /dev/mmcblk0p2对其进行格式化</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0009.png" alt=""></p><p>​ 此时我们可以用mount命令挂载该分区到我们想要的目录</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>mount <span class="token operator">-</span>t ext3 <span class="token operator">/</span>dev<span class="token operator">/</span>mmcblk0p2 <span class="token operator">/</span>mnt<span class="token operator">/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ 通过df –Th命令查看是否挂载成功。</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0010.png" alt=""></p><p>​ 当然我们也可以挂载mmcblk0p1这个分区，也是先指定某种文件系统格式化该分区，然后再用mount命令指定挂载的格式的同时挂载，最后df –Th命令查看是否挂载成功。</p><p>​ U盘的分区，格式化，挂载等操作和sd卡一致，只是将/dev/mmcblk0 变成了/dev/sda1。</p><h4 id="_15-1-5-介绍分区表" tabindex="-1"><a class="header-anchor" href="#_15-1-5-介绍分区表" aria-hidden="true">#</a> 15.1.5 介绍分区表</h4><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0011.png" alt=""></p><p>​ 上图是利用fdisk 里的p功能字，打印分区表功能显示的。</p><p>​ Device：表示这是哪一个分区，这里表示是mmcblk0的的一个分区；</p><p>​ Boot：表示启动引导标志；</p><p>​ StartCHS：分区开始的柱面、磁头、扇区；</p><p>​ EndCHS：分区结束的柱面、磁头、扇区；</p><p>​ StartLBA：逻辑块地址起始位置；</p><p>​ EndLBA： 逻辑块地址结束位置；</p><p>​ Sectors： 扇区数量；</p><p>​ Size：分区大小。</p><p>​ Id与Type：成对出现，id表示文件系统类型编号，type表示文件系统类型标记</p><p>​ 注：这里的Id与Type其实只是做个标记，并没有实际变成我们想要的文件系统格式，因此如果需要挂载时，还需要用mkfs相关命令的格式化为对应文件系统格式后再挂载。</p><h2 id="_15-2-自动挂载u盘" tabindex="-1"><a class="header-anchor" href="#_15-2-自动挂载u盘" aria-hidden="true">#</a> 15.2 自动挂载U盘</h2><h3 id="_15-2-1-udev规则" tabindex="-1"><a class="header-anchor" href="#_15-2-1-udev规则" aria-hidden="true">#</a> 15.2.1 udev规则</h3><p>​ udev是Linux（linux2.6内核之后）默认的设备管理工具。udev 以守护进程的形式运行，通过侦听内核发出来的 uevent 来管理 /dev目录下的设备文件。通过udev编写对应规则，实现设备节点变化时做出规定的动作，例如本节所说的热拔插实验、</p><p>​ udev常用的规则我们了解下。</p><p>​ 1）规则文件中以 &quot;#&quot; 开头的行以及空行将被忽略；</p><pre><code> 2）规则文件必须以 .rules 作为后缀名，否则将被忽略；

 3）规则文件分别位于： 系统规则目录(/usr/lib/udev/rules.d)、 运行时规则目录(/run/udev/rules.d)、 本机规则目录(/etc/udev/rules.d)，/etc/ 的优先级最高、 /run/ 的优先级居中、 /usr/lib/ 的优先级最低，也就是说我们可以在本机规则目录(/etc/udev/rules.d)下添加新的规则，它优先级最高，如果存有低优先级的同类规则，也会被高优先级的新规则替换掉，规则文件开头的数字越小它的执行顺序越靠前。

 4）&quot;键&quot;有两种类型：匹配与赋值。 如果某条规则的所有匹配键的值都匹配成功，那么就表示此条规则匹配成功， 也就是此条规则中的所有赋值键都会被赋予指定的值。
</code></pre><p>​ 匹配类：</p><p>​ ①“==”等于；</p><p>​ ②“!=”不等于；</p><p>​ ③“ACTION”匹配事件的动作，例如&quot;add&quot;表示插入一个设备；</p><p>​ ④“KERNEL”匹配设备的内核名称，如sda；</p><p>​ ⑤“SUBSYSTEM” 所属的子系统。例如&quot;sound&quot;或&quot;net&quot;等。</p><p>​ 赋值类：</p><p>​ ①“=”，为键赋予指定的值；</p><p>​ ②“LABEL”设置一个可用作 GOTO 跳转目标的标签；</p><p>​ ③“GOTO” 跳转到下一个匹配的 LABEL 标签所在的规则；</p><p>​ ④“RUN”{类型}对于每一个设备事件来说，在处理完规则之后，都可以再接着执行一个程序列表(默认为空)。 不同的&quot;类型&quot;含义如下：&quot;program&quot;一个外部程序， 如果是相对路径， 那么视为相对于 /usr/lib/udev 目录。 否则必须使用绝对路径。如果未明确指定&quot;类型&quot;， 那么这是默认值。&quot;builtin&quot;与 program 类似，但是仅用于表示内置的程序。程序名与其参数之间用空格分隔。 如果参数中含有空格，那么必须使用单引号(&#39;)界定。仅可使用运行时间非常短的前台程序， 切勿设置任何后台守护进程或者长时间运行的程序</p><p>​</p><p>​ 如需更加详细关于udev内容可以参考这两篇文章《udev 中文手册 [金步国]》，《Writing udev rules.html》文章链接已保存在本章对应目录下。</p><h3 id="_15-2-2-正则表达式" tabindex="-1"><a class="header-anchor" href="#_15-2-2-正则表达式" aria-hidden="true">#</a> 15.2.2 正则表达式</h3><p>​ 在udev的设备匹配上用到正则表达式，我们大致了解下，如需更加详细的内容可以参考这篇文章《正则表达式30分钟入门教程》，文章链接已保存在本章对应目录下。</p><p>①在电脑上查找文件，如果需要找‘.c’文件，我们通常会用‘*.c’就可以查找全部的‘.c’文件，如下图</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0012.png" alt=""></p><p>这里使用的 * 就是通配符，表示任意字符。</p><p>②如果我们想要更加精确的表达的话就无能为力了，因此引入了正则表达式。</p><p>·：表示任意字符（换行符除外）；</p><p>*：表示重复0次或更多次；</p><p>+：表示重复1次或更多次；</p><p>？：表示重复0次或1次；</p><p>[~]：表示这里面的字符里的某一个，例如[abc]表示abc中的其中一个，[1-9]表示1至9的其中一个。</p><p>​ 例如leds?[1-3]，其中s？表示s出现0次或者1次，[1-3]？表示1至3的某一个，出现0次或1次，根据以上信息匹配的结果就是leds，led1，led2，led3。我们通过一个语句就匹配了4个设备，多么简练。</p><h3 id="_15-2-3-自动挂载u盘" tabindex="-1"><a class="header-anchor" href="#_15-2-3-自动挂载u盘" aria-hidden="true">#</a> 15.2.3 自动挂载U盘</h3><p>①创建用于挂载U盘的目录</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>mkdir <span class="token operator">/</span>mnt<span class="token operator">/</span>usb –p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>②在/etc/udev/rules.d目录下添加用于检测U盘插入规则（add），终端下执行以下命令创建第一个U盘插入规则。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>vim <span class="token operator">/</span>etc<span class="token operator">/</span>udev<span class="token operator">/</span>rules<span class="token punctuation">.</span>d<span class="token operator">/</span><span class="token number">11</span><span class="token operator">-</span>add<span class="token operator">-</span>usb<span class="token punctuation">.</span>rules 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在11-add-usb.rules中添加如下内容：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>ACTION<span class="token operator">!=</span><span class="token string">&quot;add&quot;</span><span class="token punctuation">,</span>GOTO<span class="token operator">=</span><span class="token string">&quot;END&quot;</span>
KERNEL<span class="token operator">==</span><span class="token string">&quot;sda[0-9]&quot;</span><span class="token punctuation">,</span>RUN<span class="token operator">+=</span><span class="token string">&quot;/etc/mount-usb.sh %k&quot;</span>
LABEL<span class="token operator">=</span><span class="token string">&quot;END&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 上面的内容意思是：如果不是add添加事件，那么就跳到END标签处结束，如果是add事件那么执行以下规则，如果添加的设备是sda0至sda9中任意一个，那么就执行RUN后面的内容，此处是一个脚本，一个挂载U盘的脚本，它还带有个参数%k，表示kernel的值。</p><p>​ 然后在/etc/目录下创建mount-usb.sh脚本</p><p>​ 在mount-usb.sh中添加如下内容：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>sh
mount  <span class="token operator">-</span>t vfat <span class="token operator">/</span>dev<span class="token operator">/</span>$<span class="token number">1</span> <span class="token operator">/</span>mnt<span class="token operator">/</span>usb
sync
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 上面的内容意思是：#!/bin/sh表示是脚本文件，按脚本文件解析，mount -t vfat /dev/$1 /mnt/usb表示按vfat格式将/dev/$1挂载到/mnt/usb目录下，其中这里的$1就是之前规则里传入进来的%k，也就是kernel值。Sync表示同步U盘数据。</p><p>​ 最后记得给脚本文件添加执行权限。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>chmod <span class="token operator">+</span>x <span class="token operator">/</span>etc<span class="token operator">/</span>mount<span class="token operator">-</span>usb<span class="token punctuation">.</span>sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>③在/etc/udev/rules.d目录下添加用于检测U盘移出规则（remove），终端下执行以下命令创建第U盘移出规则。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>vim <span class="token operator">/</span>etc<span class="token operator">/</span>udev<span class="token operator">/</span>rules<span class="token punctuation">.</span>d<span class="token operator">/</span><span class="token number">11</span><span class="token operator">-</span>remove<span class="token operator">-</span>usb<span class="token punctuation">.</span>rules
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在11-remove-usb.rules中添加如下内容：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>ACTION<span class="token operator">!=</span><span class="token string">&quot;remove&quot;</span><span class="token punctuation">,</span>GOTO<span class="token operator">=</span><span class="token string">&quot;END&quot;</span>
KERNEL<span class="token operator">==</span><span class="token string">&quot;sda[0-9]&quot;</span><span class="token punctuation">,</span>RUN<span class="token operator">+=</span><span class="token string">&quot;/etc/umount-usb.sh %k&quot;</span>
LABEL<span class="token operator">=</span><span class="token string">&quot;END&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的内容意思是：如果不是remove添加事件，那么就跳到END标签处结束，如果是remove事件那么执行以下规则，如果移出的设备是sda0至sda9中任意一个，那么就执行RUN后面的内容，此处是一个脚本，一个卸载U盘的脚本，它还带有个参数%k，表示kernel的值。</p><p>​ 然后在/etc/目录下创建umount-usb.sh脚本</p><p>​ 在umount-usb.sh中添加如下内容：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>sh
sync
umount <span class="token operator">/</span>mnt<span class="token operator">/</span>usb
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 上面的内容意思是：#!/bin/sh表示是脚本文件，按脚本文件解析，先同步U盘数据，然后再卸载，其中这里的$1就是之前规则里传入进来的%k，也就是kernel值。</p><p>​ 最后记得给脚本文件添加执行权限。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>chmod <span class="token operator">+</span>x <span class="token operator">/</span>etc<span class="token operator">/</span>umount<span class="token operator">-</span>usb<span class="token punctuation">.</span>sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>④设置好规则后，当我们插入U盘，执行df –Th就会显示如下图</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0013.png" alt=""></p><pre><code> 表明/dev/sda1已经成功挂载在/mnt/usb目录下了。
</code></pre><p>​ 注1： vfat格式也就是fat32格式，使用vfat格式是由于windows操作系统与linux操作系统都支持，这样U盘就可以在windows操作系统与linux操作系统之间作为交换文件的介质。</p><p>​ 注2：Linux 系统中欲写入U盘等存储介质内时，有的时候为了效率起见，会写到 filesystem buffer 中，这个 buffer 是一块记忆体空间，如果欲真正的写入U盘等存储介质内需要执行sync 指令，它会将存于 buffer 中的数据强制写入U盘等存储介质内，这也是为什么脚本里在要加入sync的原因。</p><h2 id="_15-3-挂载后就是一般的读写文件" tabindex="-1"><a class="header-anchor" href="#_15-3-挂载后就是一般的读写文件" aria-hidden="true">#</a> 15.3 挂载后就是一般的读写文件</h2><p>​ 成功挂载后，我们就可以在挂载目录下进行创建，修改等文件操作，就等同于操作U盘上的文件。</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0014.png" alt=""></p><pre><code>  如上图，我们在终端使用以下命令创建两个文本文件。
</code></pre><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>touch <span class="token operator">/</span>mnt<span class="token operator">/</span>usb<span class="token operator">/</span><span class="token number">111.</span>txt
touch <span class="token operator">/</span>mnt<span class="token operator">/</span>usb<span class="token operator">/</span><span class="token number">222.</span>txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 然后再拔出U盘，插到电脑中查看是否存在111.tx与222.txt</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0015.png" alt=""></p><p>​ 我们可用在上面添加些内容，然后再插入开发板，查看电脑上修改的内容在开发板上是否显示。在111.txt中添加abc，在222.txt中添加100ask，保存，弹出U盘，插入开发板。 通过cat命令查看内容，如下图</p><p><img src="http://photos.100ask.net/NewHomeSite/StoreDevice_Image_Image0016.png" alt=""></p><p>​ 显示的内容正确，以后我们就可以通过U盘把电脑的东西往开发板上搬了。</p>`,135),o=[t];function r(d,c){return a(),s("div",null,o)}const l=e(p,[["render",r],["__file","15_StoreDevice.html.vue"]]);export{l as default};
