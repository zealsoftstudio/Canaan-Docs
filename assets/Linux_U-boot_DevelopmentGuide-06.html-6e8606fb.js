import{_ as e,o as p,c as t,e as m}from"./app-21fd3c9b.js";const i={},o=m(`<h2 id="_8-常用接口函数" tabindex="-1"><a class="header-anchor" href="#_8-常用接口函数" aria-hidden="true">#</a> 8 常用接口函数</h2><h3 id="_8-1-fdt-相关接口" tabindex="-1"><a class="header-anchor" href="#_8-1-fdt-相关接口" aria-hidden="true">#</a> 8.1 fdt 相关接口</h3><ol><li>const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)</li></ol><p><em>•</em> 作用：检索指定属性的值</p><p><em>•</em> 参数：</p><p>​ <em>•</em> fdt: 工作 flattened device tree</p><p>​ <em>•</em> nodeoffset: 待修改节点的偏移</p><p>​ <em>•</em> name: 待检索的属性名</p><p>​ <em>•</em> lenp: 检索属性值的长度（会被覆盖）或者为 NULL</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 非空（属性值的指针）：成功</p><p>​ <em>•</em> NULL（lenp 为空）：失败</p><p>​ <em>•</em> 失败代码（lenp 非空）：失败</p><ol start="2"><li>int fdt_set_node_status(void *fdt, int nodeoffset, enum fdt_status status, unsigned int error_code)</li></ol><p><em>•</em> 作用：设置节点状态</p><p><em>•</em> 参数：</p><p>​ <em>•</em> fdt: 工作 flattened device tree</p><p>​ <em>•</em> nodeoffset: 待修改节点的偏移</p><p>​ <em>•</em> status:FDT_STATUS_OKAY, FDT_STATUS_DISABLED, FDT_STATUS_FAIL, FDT_STATUS_FAIL_ERROR_CODE</p><p>​ <em>•</em> error_code:optional, only used if status is FDT_STATUS_FAIL_ERROR_CODE</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> 非 0: 失败</p><ol start="3"><li>int fdt_path_offset(const void *fdt, const char *path)</li></ol><p><em>•</em> 作用：通过全路径查找节点的偏移量</p><p><em>•</em> 参数：</p><p>​ <em>•</em> fdt: 工作 fdt</p><p>​ <em>•</em> path: 全路径名称</p><p><em>•</em> 返回：</p><p>​ <em>•</em> &gt;=0(节点的偏移量): 成功</p><p>​ <em>•</em> &lt;0: 失败代码</p><ol start="4"><li>static inline int fdt_setprop_u32(void *fdt, int nodeoffset, const char *name, uint32_t val)</li></ol><p><em>•</em> 作用：将属性值设置为一个 32 位整型数值，如果属性值不存在，则新建该属性</p><p><em>•</em> 参数：</p><p>​ <em>•</em> fdt: 工作 flattened device tree</p><p>​ <em>•</em> nodeoffset: 待修改节点的偏移</p><p>​ <em>•</em> name: 待修改的属性名</p><p>​ <em>•</em> val:32 位目标值</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> &lt;0: 失败代码</p><ol start="5"><li>static inline int fdt_setprop_u64(void *fdt, int nodeoffset, const char *name, uint64_t val)</li></ol><p><em>•</em> 作用：与fdt_setprop_u32类似，将属性值设置为一个 64 位整型数值，如果属性值不存在，则新建该属性</p><p><em>•</em> 参数：</p><p>​ <em>•</em> fdt: 工作 flattened device tree</p><p>​ <em>•</em> nodeoffset: 待修改节点的偏移</p><p>​ <em>•</em> name: 待修改的属性名</p><p>​ <em>•</em> val:64 位目标值</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> &lt;0: 失败代码</p><ol start="6"><li>#define fdt_setprop_string(fdt, nodeoffset, name, str) fdt_setprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)</li></ol><p><em>•</em> 作用：将属性值设置为一个字符串，如果属性值不存在，则新建该属性</p><p><em>•</em> 参数：</p><p>​ <em>•</em> fdt: 工作 flattened device tree</p><p>​ <em>•</em> nodeoffset: 待修改节点的偏移</p><p>​ <em>•</em> name: 待修改的属性名</p><p>​ <em>•</em> str: 目标值</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> &lt;0: 失败代码</p><p>注意：在sys_config.fex的配置中，节点的启用状态为 0 或 1。转换到 fdt 中对应的 status 属性为disable或okay。</p><ol start="7"><li>int save_fdt_to_flash(void *fdt_buf, size_t fdt_size)</li></ol><p><em>•</em> 作用：保存修改到 flash</p><p><em>•</em> 参数：</p><p>​ <em>•</em> fdt_buf: 当前工作 flattened device tree</p><p>​ <em>•</em> fdt_size: 当前工作 flattened device tree 的大小，可以通过fdt_totalsize(fdt_buf )获取</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> &lt;0: 失败</p><ol start="8"><li>应用参考</li></ol><p>U-Boot 中 fdt 命令行的实现：cmd/fdt.c</p><h3 id="_8-2-env-相关接口函数" tabindex="-1"><a class="header-anchor" href="#_8-2-env-相关接口函数" aria-hidden="true">#</a> 8.2 env 相关接口函数</h3><ol><li>int env_set(const char *varname, const char *varvalue)</li></ol><p><em>•</em> 作用：将环境变量 varname 的值设置为 varvalue，重启失效</p><p><em>•</em> 参数：</p><p>​ <em>•</em> varname: 待设置环境变量的名称</p><p>​ <em>•</em> varvalue: 将指定的环境变量修改为该值</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> 非 0: 失败</p><ol start="2"><li>char *env_get(const char *name)</li></ol><p><em>•</em> 作用：获取指定环境变量的值</p><p><em>•</em> 参数：</p><p>​ <em>•</em> name: 变量名称</p><p><em>•</em> 返回：</p><p>​ <em>•</em> NULL: 失败</p><p>​ <em>•</em> 非空（环境变量的值）：成功</p><ol start="3"><li>int env_save(void)</li></ol><p><em>•</em> 作用：保存环境变量，重启仍保存</p><p><em>•</em> 参数: 无</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> 非 0: 失败</p><ol start="4"><li>应用参考</li></ol><p>board/sunxi/sunxi_bootargs.c update_bootargs通过 cmdline 向 kernel 提供信息，主要是通过更新bootargs变量实现env_set(&quot;bootargs&quot;, cmdline)。</p><h3 id="_8-3-调用-u-boot-命令行" tabindex="-1"><a class="header-anchor" href="#_8-3-调用-u-boot-命令行" aria-hidden="true">#</a> 8.3 调用 U-Boot 命令行</h3><ol><li>int run_command_list(const char *cmd, int len, int flag)</li></ol><p><em>•</em> 作用：执行 U-Boot 命令行</p><p><em>•</em> 参数：</p><p>​ <em>•</em> cmd: 命令字符指针</p><p>​ <em>•</em> len: 命令行长度，设置为-1 则自动获取</p><p>​ <em>•</em> flag: 任意，因为 sunxi 中没有用到</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> 非 0: 失败</p><ol start="2"><li>应用参考：</li></ol><p>common/autoboot.c autoboot_command实现了 U-Boot 的自动启动命令</p><p>s = env_get(&quot;bootcmd&quot;);</p><p>run_command_list(s, -1, 0)。</p><h3 id="_8-4-flash-的读写" tabindex="-1"><a class="header-anchor" href="#_8-4-flash-的读写" aria-hidden="true">#</a> 8.4 Flash 的读写</h3><ol><li>int sunxi_flash_read(uint start_block, uint nblock, void *buffer)</li></ol><p><em>•</em> 作用：将指定起始位置start_block的nblock读取到buffer</p><p><em>•</em> 参数：</p><p>​ <em>•</em> start_block: 起始地址</p><p>​ <em>•</em> nblock:block 个数</p><p>​ <em>•</em> buffer: 内存地址</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> 非 0: 失败</p><ol start="2"><li>int sunxi_flash_write(uint start_block, uint nblock, void *buffer)</li></ol><p><em>•</em> 作用：将buffer写入指定起始位置start_block的nblock中</p><p><em>•</em> 参数：</p><p>​ <em>•</em> start_block: 起始地址</p><p>​ <em>•</em> nblock:block 个数</p><p>​ <em>•</em> buffer: 内存地址</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> 非 0: 失败</p><ol start="3"><li>int sunxi_sprite_read(uint start_block, uint nblock, void *buffer)</li></ol><p><em>•</em> 作用与sunxi_flash_read相似</p><ol start="4"><li>int sunxi_sprite_write(uint start_block, uint nblock, void *buffer)</li></ol><p><em>•</em> 作用与sunxi_flash_write相似</p><ol start="5"><li>应用参考</li></ol><p>common/sunxi/board_helper.c sunxi_set_bootcmd_from_mis实现了对 misc 分区的读写操作</p><h3 id="_8-5-获取分区信息" tabindex="-1"><a class="header-anchor" href="#_8-5-获取分区信息" aria-hidden="true">#</a> 8.5 获取分区信息</h3><ol><li>int sunxi_partition_get_partno_byname(const char *part_name)</li></ol><p><em>•</em> 作用：根据分区名称获取分区号</p><p><em>•</em> 参数：</p><p>​ <em>•</em> part_name: 分区名称</p><p><em>•</em> 返回：</p><p>​ <em>•</em> &lt;0: 失败</p><p>​ <em>•</em> &gt;0（分区号）：成功</p><ol start="2"><li>int sunxi_partition_get_info_byname(const char *part_name, uint *part_offset, uint *part_size)</li></ol><p><em>•</em> 作用：根据分区名称获取分区的偏移量和大小</p><p><em>•</em> 参数：</p><p>​ <em>•</em> part_name: 分区名称</p><p>​ <em>•</em> part_offset: 分区的偏移量</p><p>​ <em>•</em> part_size: 分区的大小</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0: 成功</p><p>​ <em>•</em> -1: 失败</p><ol start="3"><li>uint sunxi_partition_get_offset_byname(const char *part_name)</li></ol><p><em>•</em> 作用：根据分区名称获取偏移量</p><p><em>•</em> 参数：</p><p>​ <em>•</em> part_name: 分区名称</p><p><em>•</em> 返回：</p><p>​ <em>•</em> &lt;=0 : 失败</p><p>​ <em>•</em> &gt;0 : 成功</p><ol start="4"><li>int sunxi_partition_get_info(const char *part_name, disk_partition_t *info)</li></ol><p><em>•</em> 作用：根据part_name获取分区信息</p><p><em>•</em> 参数：</p><p>​ <em>•</em> part_name: 分区名称</p><p>​ <em>•</em> info: 分区信息</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 非 0: 失败</p><p>​ <em>•</em> 0: 成功</p><ol start="5"><li>lbaint_t sunxi_partition_get_offset(int part_index)</li></ol><p><em>•</em> 作用：card sprite 模式下获取分区的偏移量</p><p><em>•</em> 参数：</p><p>​ <em>•</em> part_index: 分区号</p><p><em>•</em> 返回：</p><p>​ <em>•</em> &gt;=0（偏移量）：成功</p><p>​ <em>•</em> -1: 失败</p><ol start="6"><li>应用参考</li></ol><p>启动时加载图片：drivers/video/sunxi/logo_display/sunxi_load_bmp.c</p><h3 id="_8-6-gpio-相关操作" tabindex="-1"><a class="header-anchor" href="#_8-6-gpio-相关操作" aria-hidden="true">#</a> 8.6 GPIO 相关操作</h3><ol><li>int fdt_get_one_gpio(const char* node_path, const char* prop_name,user_gpio_set_t* gpio_list)</li></ol><p><em>•</em> 作用：根据路径node_path和 gpio 名称prop_name获取 gpio 配置</p><p><em>•</em> 参数：</p><p>​ <em>•</em> node_path：fdt 路径</p><p>​ <em>•</em> prop_name：gpio 名称</p><p>​ <em>•</em> gpio_list：待获取的 gpio 信息</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0：成功</p><p>​ <em>•</em> -1：失败</p><ol start="2"><li>ulong sunxi_gpio_request(user_gpio_set_t *gpio_list, __u32 group_count_max)</li></ol><p><em>•</em> 作用：根据 gpio 配置获取 gpio 操作句柄</p><p><em>•</em> 参数：</p><p>​ <em>•</em> gpio_list：gpio 配置列表，可以由fdt_get_one_gpio获得</p><p>​ <em>•</em> group_count_max: gpio_list中最大的 gpio 配置个数</p><p><em>•</em> 返回：</p><p>​ <em>•</em> 0：失败</p><p>​ <em>•</em> &gt;0（gpio 操作句柄）：成功</p><ol start="3"><li>__s32 gpio_write_one_pin_value(ulong p_handler, __u32 value_to_gpio, const char *gpio_name)</li></ol><p><em>•</em> 作用：根据 gpio 操作句柄写数据</p><p><em>•</em> 参数：</p><p>​ <em>•</em> p_handler：gpio 操作句柄，可由sunxi_gpio_request获取</p><p>​ <em>•</em> value_to_gpio：待写入数据，0 或 1</p><p>​ <em>•</em> gpio_name：gpio 名称</p><p><em>•</em> 返回：</p><p>​ <em>•</em> EGPIO_SUCCESS：成功</p><p>​ <em>•</em> EGPIO_FAIL：失败</p><ol start="4"><li>应用参考</li></ol><p>操作 led 状态：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ssprite/sprite_led.c

user_gpio_set_t gpio_init;

fdt_get_one_gpio(&quot;/soc/card_boot&quot;, &quot;sprite_gpio0&quot;, &amp;gpio_init); //获取/soc/card_boot中sprite_gpio0的gpio配置

sprite_led_hd = sunxi_gpio_request(&amp;gpio_init, 1); //获取gpio操作句柄

gpio_write_one_pin_value(sprite_led_hd, sprite_led_status, &quot;sprite_gpio0&quot;); //操作led状态
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-常用资源的初始化阶段" tabindex="-1"><a class="header-anchor" href="#_9-常用资源的初始化阶段" aria-hidden="true">#</a> 9 常用资源的初始化阶段</h2><p><em>•</em> env ：环境变量初始化后可以访问</p><p><em>•</em> fdt ：在 U-Boot 运行开始即可访问</p><p><em>•</em> malloc ：在重定位后才能访问</p>`,210),n=[o];function a(l,s){return p(),t("div",null,n)}const r=e(i,[["render",a],["__file","Linux_U-boot_DevelopmentGuide-06.html.vue"]]);export{r as default};
